name: Deploy to AKS

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: acrkubeoptioprod.azurecr.io
  IMAGE_NAME: kubeopt-com
  AKS_CLUSTER_NAME: aks-kubeopt-com-prod
  AKS_RESOURCE_GROUP: rg-kubeopt-com-prod
  NAMESPACE: kubeopt-com

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: production  # Requires approval and uses production secrets
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS_PROD }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to Azure Container Registry
      run: |
        az acr login --name acrkubeoptioprod

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Get AKS credentials
      run: |
        az aks get-credentials --resource-group ${{ env.AKS_RESOURCE_GROUP }} --name ${{ env.AKS_CLUSTER_NAME }}

    - name: Install kubelogin
      run: |
        # Download and install kubelogin
        curl -LO https://github.com/Azure/kubelogin/releases/download/v0.0.32/kubelogin-linux-amd64.zip
        unzip kubelogin-linux-amd64.zip
        sudo mv bin/linux_amd64/kubelogin /usr/local/bin/
        rm -rf kubelogin-linux-amd64.zip bin/

    - name: Convert kubeconfig for Azure AD
      run: |
        kubelogin convert-kubeconfig -l azurecli

    - name: Create namespace if not exists
      run: |
        kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

    - name: Install NGINX Ingress Controller
      run: |
        # Install NGINX Ingress Controller if not already installed
        if ! kubectl get namespace ingress-nginx &> /dev/null; then
          echo "Installing NGINX Ingress Controller..."
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/cloud/deploy.yaml
          
          # Wait for ingress controller to be ready
          echo "Waiting for ingress controller to be ready..."
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=300s
        else
          echo "NGINX Ingress Controller already installed"
        fi

    - name: Install cert-manager
      run: |
        # Install cert-manager if not already installed
        if ! kubectl get namespace cert-manager &> /dev/null; then
          echo "Installing cert-manager..."
          kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.2/cert-manager.yaml
          
          # Wait for cert-manager to be ready
          echo "Waiting for cert-manager components to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/cert-manager -n cert-manager
          kubectl wait --for=condition=available --timeout=300s deployment/cert-manager-webhook -n cert-manager
          kubectl wait --for=condition=available --timeout=300s deployment/cert-manager-cainjector -n cert-manager
          
          echo "‚úÖ cert-manager installed successfully"
        else
          echo "cert-manager already installed"
        fi

    - name: Create or update secrets
      run: |
        # Delete existing secret if it exists (ignore errors)
        kubectl delete secret kubeopt-secrets -n ${{ env.NAMESPACE }} --ignore-not-found=true
        
        # Create new secret
        kubectl create secret generic kubeopt-secrets \
          --namespace=${{ env.NAMESPACE }} \
          --from-literal=secret-key="${{ secrets.FLASK_SECRET_KEY }}"

    - name: Deploy to AKS
      run: |
        # Replace image tag in deployment manifest
        sed -i "s|{{IMAGE_TAG}}|${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}|g" k8s/deployment.yaml
        
        # Apply Kubernetes manifests
        kubectl apply -f k8s/ -n ${{ env.NAMESPACE }}
        
        # Wait for deployment to be available (much faster with proper health checks)
        kubectl wait --for=condition=available --timeout=120s deployment/kubeopt-website -n ${{ env.NAMESPACE }}
        
        # Verify pods are running and ready
        kubectl get pods -n ${{ env.NAMESPACE }} -l app=kubeopt-website
        
        # Quick health check
        kubectl describe deployment kubeopt-website -n ${{ env.NAMESPACE }} | grep -E "(Replicas|Conditions)"

    - name: Get service info
      run: |
        echo "Getting service information..."
        kubectl get services -n ${{ env.NAMESPACE }}
        kubectl get ingress -n ${{ env.NAMESPACE }} || echo "No ingress found"
        
        echo "Getting pod status..."
        kubectl get pods -n ${{ env.NAMESPACE }}
        
        echo "Getting ingress controller external IP..."
        EXTERNAL_IP=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "Not available yet")
        echo "External IP: $EXTERNAL_IP"

    - name: SSL Certificate Management and Verification
      run: |
        echo "=== SSL Certificate Management ==="
        
        # Wait for ingress and services to be ready
        sleep 60
        
        # Check certificate status
        echo "Checking SSL certificate status..."
        kubectl get certificates -n ${{ env.NAMESPACE }} || echo "No certificates found yet"
        
        # Check for any failed challenges
        echo "Checking ACME challenges..."
        if kubectl get challenges -n ${{ env.NAMESPACE }} 2>/dev/null; then
          echo "Found ACME challenges, checking status..."
          kubectl describe challenges -n ${{ env.NAMESPACE }}
        else
          echo "No active ACME challenges"
        fi
        
        # Check cert-manager logs if certificates are not ready
        CERT_READY=$(kubectl get certificate kubeopt-com-tls -n ${{ env.NAMESPACE }} -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "False")
        
        if [ "$CERT_READY" != "True" ]; then
          echo "‚ö†Ô∏è SSL certificate not ready yet, this is normal for new deployments"
          echo "Checking cert-manager logs for issues..."
          kubectl logs -n cert-manager deployment/cert-manager --tail=20 || echo "Could not fetch cert-manager logs"
          
          # Check if there are any limit range issues
          echo "Checking for resource limit issues..."
          kubectl get limitrange -n ${{ env.NAMESPACE }}
          kubectl describe limitrange -n ${{ env.NAMESPACE }} 2>/dev/null || echo "No limit ranges found"
          
          # Force certificate renewal if stuck
          echo "Attempting to force certificate renewal..."
          kubectl delete challenges --all -n ${{ env.NAMESPACE }} --ignore-not-found=true
          kubectl annotate ingress kubeopt-website-ingress -n ${{ env.NAMESPACE }} cert-manager.io/cluster-issuer=letsencrypt-prod --overwrite
          
          echo "SSL certificate generation initiated. It may take 5-10 minutes to complete."
          echo "Check certificate status with: kubectl get certificates -n ${{ env.NAMESPACE }}"
        else
          echo "‚úÖ SSL certificate is ready!"
        fi

    - name: Run comprehensive health check
      run: |
        # Wait for service to be ready
        sleep 30
        
        # Get the external IP
        EXTERNAL_IP=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
        
        if [ ! -z "$EXTERNAL_IP" ] && [ "$EXTERNAL_IP" != "null" ]; then
          echo "Testing health endpoint via external IP: $EXTERNAL_IP"
          
          # Test HTTP redirect
          echo "Testing HTTP to HTTPS redirect..."
          curl -I -H "Host: kubeopt.com" http://$EXTERNAL_IP --max-time 10 || echo "HTTP test failed"
          
          # Test HTTPS health endpoint (with and without SSL verification)
          echo "Testing HTTPS health endpoint..."
          if curl -H "Host: kubeopt.com" https://$EXTERNAL_IP/health --max-time 30 2>/dev/null; then
            echo "‚úÖ HTTPS with valid SSL certificate working!"
          elif curl -k -H "Host: kubeopt.com" https://$EXTERNAL_IP/health --max-time 30 2>/dev/null; then
            echo "‚ö†Ô∏è HTTPS working but SSL certificate may still be generating"
          else
            echo "‚ùå HTTPS health check failed"
          fi
          
          # Test main page
          echo "Testing main page..."
          if curl -H "Host: kubeopt.com" https://$EXTERNAL_IP --max-time 30 -s | head -5 2>/dev/null; then
            echo "‚úÖ Main page accessible with SSL!"
          elif curl -k -H "Host: kubeopt.com" https://$EXTERNAL_IP --max-time 30 -s | head -5 2>/dev/null; then
            echo "‚ö†Ô∏è Main page accessible, SSL certificate still generating"
          else
            echo "‚ùå Main page test failed"
          fi
          
          # Check SSL certificate details
          echo "Checking SSL certificate..."
          openssl s_client -connect $EXTERNAL_IP:443 -servername kubeopt.com -timeout 10 </dev/null 2>/dev/null | openssl x509 -noout -subject -dates 2>/dev/null || echo "SSL certificate check failed (normal for new deployments)"
          
          echo ""
          echo "================================================"
          echo "‚úÖ External IP available: $EXTERNAL_IP"
          echo "üåê Update your DNS to point kubeopt.com to $EXTERNAL_IP"
          echo "üîí SSL certificates will be automatically generated by Let's Encrypt"
          echo "üì± Test your site: https://kubeopt.com"
          echo "================================================"
        else
          echo "‚ö†Ô∏è External IP not yet available. This is normal for new deployments."
          echo "The load balancer may take a few minutes to assign an external IP."
        fi

    - name: Cleanup old images (optional)
      if: github.ref == 'refs/heads/main'
      run: |
        # Keep only last 5 images to save ACR storage costs
        az acr repository show-tags --name acrkubeoptioprod --repository ${{ env.IMAGE_NAME }} --orderby time_desc --output tsv | tail -n +6 | xargs -I {} az acr repository delete --name acrkubeoptioprod --image ${{ env.IMAGE_NAME }}:{} --yes || true