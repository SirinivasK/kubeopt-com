name: Application Deployment

on:
  push:
    branches: [ main ]
    paths:
      - 'app/**'
      - 'k8s/**'
      - 'Dockerfile'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
        - deploy
        - stop
        - start
        - scale

permissions:
  id-token: write
  contents: read

env:
  AZURE_RESOURCE_GROUP: rg-kubeopt-com-prod
  AZURE_CLUSTER_NAME: aks-kubeopt-com-prod
  AZURE_REGISTRY_NAME: acrkubeoptioprod
  KUBERNETES_NAMESPACE: kubeopt-com

jobs:
  # Build Application (No approval needed)
  build:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event.inputs.action == 'deploy'
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build and push Docker image
      id: build
      run: |
        # Login to ACR
        az acr login --name ${{ env.AZURE_REGISTRY_NAME }}
        
        # Build images
        IMAGE_TAG="${{ github.sha }}"
        docker build -t ${{ env.AZURE_REGISTRY_NAME }}.azurecr.io/kubeopt-website:${IMAGE_TAG} .
        docker build -t ${{ env.AZURE_REGISTRY_NAME }}.azurecr.io/kubeopt-website:latest .
        
        # Push images
        docker push ${{ env.AZURE_REGISTRY_NAME }}.azurecr.io/kubeopt-website:${IMAGE_TAG}
        docker push ${{ env.AZURE_REGISTRY_NAME }}.azurecr.io/kubeopt-website:latest
        
        echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
        echo "‚úÖ Image built and pushed: ${IMAGE_TAG}"

  # Production Deployment (Requires prod approval)
  deploy-prod:
    runs-on: ubuntu-latest
    needs: build
    if: needs.build.outputs.image_tag != ''
    environment: prod  # üîí APPROVAL REQUIRED FOR PRODUCTION
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AZURE_CLUSTER_NAME }} \
          --overwrite-existing

    - name: Install kubelogin
      run: |
        curl -LO https://github.com/Azure/kubelogin/releases/download/v0.0.32/kubelogin-linux-amd64.zip
        unzip kubelogin-linux-amd64.zip
        sudo mv bin/linux_amd64/kubelogin /usr/local/bin/
        rm -rf kubelogin-linux-amd64.zip bin/

    - name: Convert kubeconfig for Azure AD
      run: |
        kubelogin convert-kubeconfig -l azurecli

    - name: Wait for cluster to be ready
      run: |
        echo "‚è≥ Waiting for cluster nodes to be ready..."
        kubectl wait --for=condition=Ready nodes --all --timeout=300s
        kubectl get nodes

    - name: Create namespace if not exists
      run: |
        kubectl create namespace ${{ env.KUBERNETES_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

    - name: Install NGINX Ingress Controller
      run: |
        # Install NGINX Ingress Controller if not already installed
        if ! kubectl get namespace ingress-nginx &> /dev/null; then
          echo "Installing NGINX Ingress Controller..."
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/cloud/deploy.yaml
          
          # Wait for ingress controller to be ready
          echo "Waiting for ingress controller to be ready..."
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=300s
        else
          echo "NGINX Ingress Controller already installed"
        fi

    - name: Install cert-manager
      run: |
        # Install cert-manager if not already installed
        if ! kubectl get namespace cert-manager &> /dev/null; then
          echo "Installing cert-manager..."
          kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.2/cert-manager.yaml
          
          # Wait for cert-manager to be ready
          echo "Waiting for cert-manager components to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/cert-manager -n cert-manager
          kubectl wait --for=condition=available --timeout=300s deployment/cert-manager-webhook -n cert-manager
          kubectl wait --for=condition=available --timeout=300s deployment/cert-manager-cainjector -n cert-manager
          
          echo "‚úÖ cert-manager installed successfully"
        else
          echo "cert-manager already installed"
        fi

    - name: Create or update secrets
      run: |
        # Delete existing secret if it exists (ignore errors)
        kubectl delete secret kubeopt-secrets -n ${{ env.KUBERNETES_NAMESPACE }} --ignore-not-found=true
        
        # Create new secret
        kubectl create secret generic kubeopt-secrets \
          --namespace=${{ env.KUBERNETES_NAMESPACE }} \
          --from-literal=secret-key="${{ secrets.FLASK_SECRET_KEY }}"

    - name: Deploy application
      run: |
        echo "üöÄ Deploying kubeopt.com to production..."
        
        # Apply base manifests
        kubectl apply -f k8s/secrets.yaml
        kubectl apply -f k8s/storage.yaml
        
        # Deploy with specific image tag
        sed "s|{{IMAGE_TAG}}|${{ env.AZURE_REGISTRY_NAME }}.azurecr.io/kubeopt-website:${{ needs.build.outputs.image_tag }}|g" k8s/deployment.yaml | kubectl apply -f -
        
        kubectl apply -f k8s/service.yaml
        kubectl apply -f k8s/ingress.yaml

    - name: Verify deployment
      run: |
        echo "üîç Verifying deployment..."
        kubectl rollout status deployment/kubeopt-website -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=300s
        
        echo "üìã Deployment status:"
        kubectl get pods -n ${{ env.KUBERNETES_NAMESPACE }} -o wide
        kubectl get services -n ${{ env.KUBERNETES_NAMESPACE }}
        kubectl get ingress -n ${{ env.KUBERNETES_NAMESPACE }}
        
        # Get external IP
        echo "üåê External access:"
        kubectl get ingress -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' || echo "IP pending..."

    - name: SSL Certificate Management and Verification
      run: |
        echo "=== SSL Certificate Management ==="
        
        # Wait for ingress and services to be ready
        sleep 60
        
        # Check certificate status
        echo "Checking SSL certificate status..."
        kubectl get certificates -n ${{ env.KUBERNETES_NAMESPACE }} || echo "No certificates found yet"
        
        # Check for any failed challenges
        echo "Checking ACME challenges..."
        if kubectl get challenges -n ${{ env.KUBERNETES_NAMESPACE }} 2>/dev/null; then
          echo "Found ACME challenges, checking status..."
          kubectl describe challenges -n ${{ env.KUBERNETES_NAMESPACE }}
        else
          echo "No active ACME challenges"
        fi
        
        # Check cert-manager logs if certificates are not ready
        CERT_READY=$(kubectl get certificate kubeopt-com-tls -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "False")
        
        if [ "$CERT_READY" != "True" ]; then
          echo "‚ö†Ô∏è SSL certificate not ready yet, this is normal for new deployments"
          echo "Checking cert-manager logs for issues..."
          kubectl logs -n cert-manager deployment/cert-manager --tail=20 || echo "Could not fetch cert-manager logs"
          
          echo "SSL certificate generation initiated. It may take 5-10 minutes to complete."
          echo "Check certificate status with: kubectl get certificates -n ${{ env.KUBERNETES_NAMESPACE }}"
        else
          echo "‚úÖ SSL certificate is ready!"
        fi

    - name: Run comprehensive health check
      run: |
        # Wait for service to be ready
        sleep 30
        
        # Get the external IP
        EXTERNAL_IP=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
        
        if [ ! -z "$EXTERNAL_IP" ] && [ "$EXTERNAL_IP" != "null" ]; then
          echo "Testing health endpoint via external IP: $EXTERNAL_IP"
          
          # Test HTTP redirect
          echo "Testing HTTP to HTTPS redirect..."
          curl -I -H "Host: kubeopt.com" http://$EXTERNAL_IP --max-time 10 || echo "HTTP test failed"
          
          # Test HTTPS health endpoint (with and without SSL verification)
          echo "Testing HTTPS health endpoint..."
          if curl -H "Host: kubeopt.com" https://$EXTERNAL_IP/health --max-time 30 2>/dev/null; then
            echo "‚úÖ HTTPS with valid SSL certificate working!"
          elif curl -k -H "Host: kubeopt.com" https://$EXTERNAL_IP/health --max-time 30 2>/dev/null; then
            echo "‚ö†Ô∏è HTTPS working but SSL certificate may still be generating"
          else
            echo "‚ùå HTTPS health check failed"
          fi
          
          # Test main page
          echo "Testing main page..."
          if curl -H "Host: kubeopt.com" https://$EXTERNAL_IP --max-time 30 -s | head -5 2>/dev/null; then
            echo "‚úÖ Main page accessible with SSL!"
          elif curl -k -H "Host: kubeopt.com" https://$EXTERNAL_IP --max-time 30 -s | head -5 2>/dev/null; then
            echo "‚ö†Ô∏è Main page accessible, SSL certificate still generating"
          else
            echo "‚ùå Main page test failed"
          fi
          
          # Check SSL certificate details
          echo "Checking SSL certificate..."
          openssl s_client -connect $EXTERNAL_IP:443 -servername kubeopt.com -timeout 10 </dev/null 2>/dev/null | openssl x509 -noout -subject -dates 2>/dev/null || echo "SSL certificate check failed (normal for new deployments)"
          
          echo ""
          echo "================================================"
          echo "‚úÖ External IP available: $EXTERNAL_IP"
          echo "üåê Update your DNS to point kubeopt.com to $EXTERNAL_IP"
          echo "üîí SSL certificates will be automatically generated by Let's Encrypt"
          echo "üì± Test your site: https://kubeopt.com"
          echo "================================================"
        else
          echo "‚ö†Ô∏è External IP not yet available. This is normal for new deployments."
          echo "The load balancer may take a few minutes to assign an external IP."
        fi

  # Environment Management (Requires prod approval for stop/start)
  manage-environment:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && contains(fromJson('["stop", "start"]'), github.event.inputs.action)
    environment: prod  # üîí APPROVAL REQUIRED
    
    steps:
    - name: Azure Login
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AZURE_CLUSTER_NAME }} \
          --overwrite-existing

    - name: Install kubelogin
      run: |
        curl -LO https://github.com/Azure/kubelogin/releases/download/v0.0.32/kubelogin-linux-amd64.zip
        unzip kubelogin-linux-amd64.zip
        sudo mv bin/linux_amd64/kubelogin /usr/local/bin/
        rm -rf kubelogin-linux-amd64.zip bin/

    - name: Convert kubeconfig for Azure AD
      run: |
        kubelogin convert-kubeconfig -l azurecli

    - name: Stop Environment
      if: github.event.inputs.action == 'stop'
      run: |
        echo "üõë Stopping environment to save costs..."
        
        # Show current status
        kubectl get nodes || echo "No nodes available"
        kubectl get pods -n ${{ env.KUBERNETES_NAMESPACE }} || echo "No pods in namespace"
        
        # Scale down workloads
        kubectl scale deployment kubeopt-website -n ${{ env.KUBERNETES_NAMESPACE }} --replicas=0 || true
        
        # Scale down node pools
        az aks nodepool scale \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --cluster-name ${{ env.AZURE_CLUSTER_NAME }} \
          --name default \
          --node-count 0
          
        # Scale spot pool if exists
        az aks nodepool scale \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --cluster-name ${{ env.AZURE_CLUSTER_NAME }} \
          --name spot \
          --node-count 0 2>/dev/null || echo "No spot pool found"
        
        echo "‚úÖ Environment stopped"
        echo "üí∞ Monthly savings: ~$25-30"
        echo "üí° Only paying for: Container Registry ($5) + Load Balancer ($18) + Storage (~$2)"

    - name: Start Environment
      if: github.event.inputs.action == 'start'
      run: |
        echo "üöÄ Starting environment..."
        
        # Scale up node pools
        az aks nodepool scale \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --cluster-name ${{ env.AZURE_CLUSTER_NAME }} \
          --name default \
          --node-count 1
        
        # Wait for nodes
        echo "‚è≥ Waiting for nodes to be ready..."
        kubectl wait --for=condition=Ready nodes --all --timeout=600s
        
        # Scale up workloads
        kubectl scale deployment kubeopt-website -n ${{ env.KUBERNETES_NAMESPACE }} --replicas=1
        
        # Wait for deployment
        kubectl rollout status deployment/kubeopt-website -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=300s
        
        echo "‚úÖ Environment started and ready!"
        kubectl get nodes
        kubectl get pods -n ${{ env.KUBERNETES_NAMESPACE }}

  # Application Health Check and Monitoring
  monitoring:
    runs-on: ubuntu-latest
    if: always() && (github.event_name == 'push' || github.event.inputs.action == 'deploy')
    needs: deploy-prod
    
    steps:
    - name: Azure Login
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Cost Report
      run: |
        echo "üìä Cost Monitoring Report"
        echo "========================"
        
        # Current usage
        echo "üí∞ Current month usage:"
        az consumption usage list --top 5 --query "[?contains(instanceName, 'kubeopt')].{Resource:instanceName, Cost:pretaxCost}" --output table 2>/dev/null || echo "Usage data not available yet"
        
        # Resource count
        echo ""
        echo "üìã Active resources:"
        az resource list --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "length(@)" --output tsv | xargs echo "Total resources:"
        
        echo ""
        echo "üí° Cost optimization tips:"
        echo "‚Ä¢ Use 'stop' action when not testing to save ~$25-30/month"
        echo "‚Ä¢ Monitor with: az consumption usage list --top 10"
        echo "‚Ä¢ Budget alert set at $50/month"

    - name: Cleanup old images (optional)
      if: github.ref == 'refs/heads/main'
      run: |
        # Keep only last 5 images to save ACR storage costs
        az acr repository show-tags --name ${{ env.AZURE_REGISTRY_NAME }} --repository kubeopt-website --orderby time_desc --output tsv | tail -n +6 | xargs -I {} az acr repository delete --name ${{ env.AZURE_REGISTRY_NAME }} --image kubeopt-website:{} --yes || true